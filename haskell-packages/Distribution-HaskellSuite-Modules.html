<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Distribution.HaskellSuite.Modules</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Distribution-HaskellSuite-Modules.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Distribution-HaskellSuite-Modules.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">haskell-packages-0.2.1: Haskell suite library for package management and integration with Cabal</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Distribution.HaskellSuite.Modules</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Module monad
</a></li><li><a href="#g:2">Module names
</a></li></ul></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span>  <a href="#t:ModuleT">ModuleT</a> i m a</li><li class="src short"><a href="#v:getModuleInfo">getModuleInfo</a> :: (<a href="Distribution-HaskellSuite-Modules.html#t:MonadModule">MonadModule</a> m, <a href="Distribution-HaskellSuite-Modules.html#t:ModName">ModName</a> n) =&gt; n -&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Distribution-HaskellSuite-Modules.html#t:ModuleInfo">ModuleInfo</a> m))</li><li class="src short"><a href="#v:evalModuleT">evalModuleT</a> :: <a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> m =&gt; <a href="Distribution-HaskellSuite-Modules.html#t:ModuleT">ModuleT</a> i m a -&gt; <a href="Distribution-HaskellSuite-Packages.html#t:Packages">Packages</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-String.html#t:String">String</a> -&gt; (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/System-IO.html#t:FilePath">FilePath</a> -&gt; m i) -&gt; m a</li><li class="src short"><a href="#v:runModuleT">runModuleT</a> :: <a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> m =&gt; <a href="Distribution-HaskellSuite-Modules.html#t:ModuleT">ModuleT</a> i m a -&gt; <a href="Distribution-HaskellSuite-Packages.html#t:Packages">Packages</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-String.html#t:String">String</a> -&gt; (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/System-IO.html#t:FilePath">FilePath</a> -&gt; m i) -&gt; <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Map-Lazy.html#t:Map">Map</a> <a href="http://hackage.haskell.org/packages/archive/Cabal/1.18.0/doc/html/Distribution-ModuleName.html#t:ModuleName">ModuleName</a> i -&gt; m (a, <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Map-Lazy.html#t:Map">Map</a> <a href="http://hackage.haskell.org/packages/archive/Cabal/1.18.0/doc/html/Distribution-ModuleName.html#t:ModuleName">ModuleName</a> i)</li><li class="src short"><span class="keyword">class</span> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="#t:MonadModule">MonadModule</a> m  <span class="keyword">where</span><ul class="subs"><li><span class="keyword">type</span> <a href="#t:ModuleInfo">ModuleInfo</a> m </li><li><a href="#v:lookupInCache">lookupInCache</a> :: <a href="Distribution-HaskellSuite-Modules.html#t:ModName">ModName</a> n =&gt; n -&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Distribution-HaskellSuite-Modules.html#t:ModuleInfo">ModuleInfo</a> m))</li><li><a href="#v:insertInCache">insertInCache</a> :: <a href="Distribution-HaskellSuite-Modules.html#t:ModName">ModName</a> n =&gt; n -&gt; <a href="Distribution-HaskellSuite-Modules.html#t:ModuleInfo">ModuleInfo</a> m -&gt; m ()</li><li><a href="#v:getPackages">getPackages</a> :: m <a href="Distribution-HaskellSuite-Packages.html#t:Packages">Packages</a></li><li><a href="#v:readModuleInfo">readModuleInfo</a> :: <a href="Distribution-HaskellSuite-Modules.html#t:ModName">ModName</a> n =&gt; [<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/System-IO.html#t:FilePath">FilePath</a>] -&gt; n -&gt; m (<a href="Distribution-HaskellSuite-Modules.html#t:ModuleInfo">ModuleInfo</a> m)</li></ul></li><li class="src short"><span class="keyword">class</span>  <a href="#t:ModName">ModName</a> n  <span class="keyword">where</span><ul class="subs"><li><a href="#v:modToString">modToString</a> :: n -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-String.html#t:String">String</a></li></ul></li><li class="src short"><a href="#v:convertModuleName">convertModuleName</a> :: <a href="Distribution-HaskellSuite-Modules.html#t:ModName">ModName</a> n =&gt; n -&gt; <a href="http://hackage.haskell.org/packages/archive/Cabal/1.18.0/doc/html/Distribution-ModuleName.html#t:ModuleName">ModuleName</a></li></ul></div><div id="interface"><h1 id="g:1">Module monad
</h1><div class="doc"><p>When you need to resolve modules, you work in a <code><a href="Distribution-HaskellSuite-Modules.html#t:ModuleT">ModuleT</a></code> monad (or
 another monad that is an instance of <code><a href="Distribution-HaskellSuite-Modules.html#t:MonadModule">MonadModule</a></code>) and use the
 <code><a href="Distribution-HaskellSuite-Modules.html#v:getModuleInfo">getModuleInfo</a></code> function.
</p><p>It finds an installed module by its name and reads (and caches) its
 info from the info file. Then you run a <code><a href="Distribution-HaskellSuite-Modules.html#t:ModuleT">ModuleT</a></code> monadic action
 using <code><a href="Distribution-HaskellSuite-Modules.html#v:evalModuleT">evalModuleT</a></code> or <code><a href="Distribution-HaskellSuite-Modules.html#v:runModuleT">runModuleT</a></code>.
</p><p>To run a <code><a href="Distribution-HaskellSuite-Modules.html#t:ModuleT">ModuleT</a></code> action you'll also need to provide the set of
 packages (represented by their <code><a href="http://hackage.haskell.org/packages/archive/Cabal/1.18.0/doc/html/Distribution-InstalledPackageInfo.html#t:InstalledPackageInfo">InstalledPackageInfo</a></code>) in which to
 search for modules. You can get such a set from either
 <code><a href="Distribution-HaskellSuite-Packages.html#v:getInstalledPackages">getInstalledPackages</a></code> or <code><a href="Distribution-HaskellSuite-Packages.html#v:readPackagesInfo">readPackagesInfo</a></code>, depending on your use
 case.
</p></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:ModuleT" class="def">ModuleT</a> i m a <a href="src/Distribution-HaskellSuite-Modules.html#ModuleT" class="link">Source</a></p><div class="doc"><p>A standard module monad transformer.
</p><p><code>i</code> is the type of module info, <code>m</code> is the underlying monad.
</p></div><div class="subs instances"><p id="control.i:ModuleT" class="caption collapser" onclick="toggleSection('i:ModuleT')">Instances</p><div id="section.i:ModuleT" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Class.html#t:MonadTrans">MonadTrans</a> (<a href="Distribution-HaskellSuite-Modules.html#t:ModuleT">ModuleT</a> i)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Monad">Monad</a> (<a href="Distribution-HaskellSuite-Modules.html#t:ModuleT">ModuleT</a> i m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Functor">Functor</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Functor">Functor</a> (<a href="Distribution-HaskellSuite-Modules.html#t:ModuleT">ModuleT</a> i m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Monad">Monad</a> m, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Functor">Functor</a> m) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Applicative.html#t:Applicative">Applicative</a> (<a href="Distribution-HaskellSuite-Modules.html#t:ModuleT">ModuleT</a> i m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> (<a href="Distribution-HaskellSuite-Modules.html#t:ModuleT">ModuleT</a> i m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Functor">Functor</a> m, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Monad">Monad</a> m) =&gt; <a href="Distribution-HaskellSuite-Modules.html#t:MonadModule">MonadModule</a> (<a href="Distribution-HaskellSuite-Modules.html#t:ModuleT">ModuleT</a> i m)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:getModuleInfo" class="def">getModuleInfo</a> :: (<a href="Distribution-HaskellSuite-Modules.html#t:MonadModule">MonadModule</a> m, <a href="Distribution-HaskellSuite-Modules.html#t:ModName">ModName</a> n) =&gt; n -&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Distribution-HaskellSuite-Modules.html#t:ModuleInfo">ModuleInfo</a> m))<a href="src/Distribution-HaskellSuite-Modules.html#getModuleInfo" class="link">Source</a></p><div class="doc"><p>Tries to find the module in the current set of packages, then find the
 module's info file, and reads and caches its contents.
</p><p>Returns <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#v:Nothing">Nothing</a></code> if the module could not be found in the current set of
 packages. If the module is found, but something else goes wrong (e.g.
 there's no info file for it), an exception is thrown.
</p></div></div><div class="top"><p class="src"><a name="v:evalModuleT" class="def">evalModuleT</a><a href="src/Distribution-HaskellSuite-Modules.html#evalModuleT" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Distribution-HaskellSuite-Modules.html#t:ModuleT">ModuleT</a> i m a</td><td class="doc"><p>the monadic action to run
</p></td></tr><tr><td class="src">-&gt; <a href="Distribution-HaskellSuite-Packages.html#t:Packages">Packages</a></td><td class="doc"><p>packages in which to look for modules
</p></td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-String.html#t:String">String</a></td><td class="doc"><p>file extension of info files
</p></td></tr><tr><td class="src">-&gt; (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/System-IO.html#t:FilePath">FilePath</a> -&gt; m i)</td><td class="doc"><p>how to read information from an info file
</p></td></tr><tr><td class="src">-&gt; m a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Run a <code><a href="Distribution-HaskellSuite-Modules.html#t:ModuleT">ModuleT</a></code> action.
</p><p>This is a simplified version of <code><a href="Distribution-HaskellSuite-Modules.html#v:runModuleT">runModuleT</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:runModuleT" class="def">runModuleT</a><a href="src/Distribution-HaskellSuite-Modules.html#runModuleT" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Distribution-HaskellSuite-Modules.html#t:ModuleT">ModuleT</a> i m a</td><td class="doc"><p>the monadic action to run
</p></td></tr><tr><td class="src">-&gt; <a href="Distribution-HaskellSuite-Packages.html#t:Packages">Packages</a></td><td class="doc"><p>packages in which to look for modules
</p></td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-String.html#t:String">String</a></td><td class="doc"><p>file extension of info files
</p></td></tr><tr><td class="src">-&gt; (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/System-IO.html#t:FilePath">FilePath</a> -&gt; m i)</td><td class="doc"><p>how to read information from an info file
</p></td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Map-Lazy.html#t:Map">Map</a> <a href="http://hackage.haskell.org/packages/archive/Cabal/1.18.0/doc/html/Distribution-ModuleName.html#t:ModuleName">ModuleName</a> i</td><td class="doc"><p>initial set of module infos
</p></td></tr><tr><td class="src">-&gt; m (a, <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Map-Lazy.html#t:Map">Map</a> <a href="http://hackage.haskell.org/packages/archive/Cabal/1.18.0/doc/html/Distribution-ModuleName.html#t:ModuleName">ModuleName</a> i)</td><td class="doc"><p>return value, plus all cached module infos (that is, the initial set
 plus all infos that have been read by the action itself)
</p></td></tr></table></div><div class="doc"><p>Run a <code><a href="Distribution-HaskellSuite-Modules.html#t:ModuleT">ModuleT</a></code> action
</p></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a name="t:MonadModule" class="def">MonadModule</a> m  <span class="keyword">where</span><a href="src/Distribution-HaskellSuite-Modules.html#MonadModule" class="link">Source</a></p><div class="doc"><p>This class defines the interface that is used by <code><a href="Distribution-HaskellSuite-Modules.html#v:getModuleInfo">getModuleInfo</a></code>, so
 that you can use it in monads other than <code><a href="Distribution-HaskellSuite-Modules.html#t:ModuleT">ModuleT</a></code>.
</p><p>You don't typically have to define your own instances of this class, but
 here are a couple of cases when you might:
</p><ul><li> A pure (non-<code><a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a></code>) mockup module monad for testing purposes
</li><li> A transformer over <code><a href="Distribution-HaskellSuite-Modules.html#t:ModuleT">ModuleT</a></code>
</li><li> You need a more complex way to retrieve the module info
</li></ul></div><div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">type</span> <a name="t:ModuleInfo" class="def">ModuleInfo</a> m <a href="src/Distribution-HaskellSuite-Modules.html#ModuleInfo" class="link">Source</a></p><div class="doc"><p>The type of module info
</p></div></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:lookupInCache" class="def">lookupInCache</a> :: <a href="Distribution-HaskellSuite-Modules.html#t:ModName">ModName</a> n =&gt; n -&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Distribution-HaskellSuite-Modules.html#t:ModuleInfo">ModuleInfo</a> m))<a href="src/Distribution-HaskellSuite-Modules.html#lookupInCache" class="link">Source</a></p><p class="src"><a name="v:insertInCache" class="def">insertInCache</a> :: <a href="Distribution-HaskellSuite-Modules.html#t:ModName">ModName</a> n =&gt; n -&gt; <a href="Distribution-HaskellSuite-Modules.html#t:ModuleInfo">ModuleInfo</a> m -&gt; m ()<a href="src/Distribution-HaskellSuite-Modules.html#insertInCache" class="link">Source</a></p><p class="src"><a name="v:getPackages" class="def">getPackages</a> :: m <a href="Distribution-HaskellSuite-Packages.html#t:Packages">Packages</a><a href="src/Distribution-HaskellSuite-Modules.html#getPackages" class="link">Source</a></p><p class="src"><a name="v:readModuleInfo" class="def">readModuleInfo</a> :: <a href="Distribution-HaskellSuite-Modules.html#t:ModName">ModName</a> n =&gt; [<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/System-IO.html#t:FilePath">FilePath</a>] -&gt; n -&gt; m (<a href="Distribution-HaskellSuite-Modules.html#t:ModuleInfo">ModuleInfo</a> m)<a href="src/Distribution-HaskellSuite-Modules.html#readModuleInfo" class="link">Source</a></p><div class="doc"><p>Read the module info, given a list of search paths and the module
 name
</p></div></div><div class="subs instances"><p id="control.i:MonadModule" class="caption collapser" onclick="toggleSection('i:MonadModule')">Instances</p><div id="section.i:MonadModule" class="show"><table><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Functor">Functor</a> m, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Monad">Monad</a> m) =&gt; <a href="Distribution-HaskellSuite-Modules.html#t:MonadModule">MonadModule</a> (<a href="Distribution-HaskellSuite-Modules.html#t:ModuleT">ModuleT</a> i m)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:2">Module names
</h1><div class="top"><p class="src"><span class="keyword">class</span>  <a name="t:ModName" class="def">ModName</a> n  <span class="keyword">where</span><a href="src/Distribution-HaskellSuite-Modules.html#ModName" class="link">Source</a></p><div class="doc"><p>Different libraries (Cabal, haskell-src-exts, ...) use different types
 to represent module names. Hence this class.
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:modToString" class="def">modToString</a> :: n -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-String.html#t:String">String</a><a href="src/Distribution-HaskellSuite-Modules.html#modToString" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:ModName" class="caption collapser" onclick="toggleSection('i:ModName')">Instances</p><div id="section.i:ModName" class="show"><table><tr><td class="src"><a href="Distribution-HaskellSuite-Modules.html#t:ModName">ModName</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Distribution-HaskellSuite-Modules.html#t:ModName">ModName</a> <a href="http://hackage.haskell.org/packages/archive/Cabal/1.18.0/doc/html/Distribution-ModuleName.html#t:ModuleName">ModuleName</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:convertModuleName" class="def">convertModuleName</a> :: <a href="Distribution-HaskellSuite-Modules.html#t:ModName">ModName</a> n =&gt; n -&gt; <a href="http://hackage.haskell.org/packages/archive/Cabal/1.18.0/doc/html/Distribution-ModuleName.html#t:ModuleName">ModuleName</a><a href="src/Distribution-HaskellSuite-Modules.html#convertModuleName" class="link">Source</a></p><div class="doc"><p>Convert module name from arbitrary representation to Cabal's one
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2</p></div></body></html>